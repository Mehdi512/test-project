#input {
#  file {
#    start_position => "beginning"
#    path => ["/var/seamless/log/dealer-management-system/dealer-management-system-data.dump*", "/var/seamless/log/group-management/group-management-data.dump*"]
#    sincedb_path => "/var/seamless/log/logstash/sincedb_reseller_data_lake.log"
#  }
#}

#Filebeat pipeline configuration
input {
  pipeline { address => resellerDataLakePipeline }
}

#Filter out the logs before inserting to data lake
filter
{

        json
        {
            source => "message"
        }
        if "_jsonparsefailure" not in [tags]
        {
           if ("addReseller" in [eventName] or "updateReseller" in [eventName] and [DMS])
           {
               date
               {
                         match => ["timestamp","yyyy-MM-dd HH:mm:ss"]
                         timezone => "UTC"
                         target => "timestamp"
               }
               split
               {
                        field=>"DMS"
               }
               prune
               {
                         blacklist_names => ["^log$","^tags$","^agent$","^message$","^path$","^@version$","^host$","^ecs$","^input$","^cloud$","^event$"]
               }
               ruby
               {
                          code => '
                                  dmsData=event.get("[DMS]")
                                  dmsData.each { |key,value|
                                    if key=="resellerInfo"
                                        resellerInfoData=event.get("[DMS][#{key}]")
                                        resellerInfoData.each{ |keyRI,valueRI|
                                            if keyRI=="reseller"
                                                subFieldData=event.get("[DMS][resellerInfo][#{keyRI}]")
                                                subFieldData.each { |key,value|
						                                    if key=="dynamicData"
                                                        event.get("[DMS][resellerInfo][reseller][dynamicData]").each { |dynaKey, dynaValue|
                                                            if dynaKey == "bankProperties" && event.get("[DMS][resellerInfo][reseller][resellerTypeId]") == "DIST"
                                                                if dynaValue.is_a?(Array)
                                                                    dynaValue.each_with_index do |bank_prop, index|
                                                                        if bank_prop.is_a?(Hash)
                                                                            bank_prop.each do |bank_key, bank_value|
                                                                                keyField = "dms.resellerInfo.reseller.dynamicData.bankProperties.#{index}.#{bank_key}"
                                                                                event.set(keyField, bank_value)
                                                                            end
                                                                        end
                                                                    end
                                                                end
                                                            else
                                                                keyField="dms.resellerInfo.dynamicData.#{dynaKey}"
                                                                event.set(keyField,dynaValue)
                                                            end
                                                        }
							                                    elsif key=="address"
                                                        event.get("[DMS][resellerInfo][reseller][address]").each { |addFieldKey, addFieldValue|
                                                            keyField="dms.resellerInfo.address.#{addFieldKey}"
                                                            event.set(keyField,addFieldValue)
                                                        }
                                                    else
                                                        keyField="dms.resellerInfo.#{keyRI}.#{key}"
                                                        event.set(keyField,value)
                                                    end
                                                }
                                            elsif keyRI=="users"
                                                 subFieldData=event.get("[DMS][resellerInfo][#{keyRI}]")
                                                 keyField="dms.resellerInfo.#{keyRI}"
                                                 event.set(keyField,subFieldData)
                                            elsif keyRI == "additionalFields"
                                                additionalFieldsData = valueRI
                                                if additionalFieldsData.is_a?(Array)
                                                    additionalFieldsData.each do |field_hash|
                                                        # Check if the hash with name and value keys
                                                        if field_hash.is_a?(Hash) && field_hash.key?("name") && field_hash.key?("value")
                                                            field_name = field_hash["name"]
                                                            field_value = field_hash["value"]
                                                            # Only create field if name is not empty
                                                            if field_name && !field_name.empty?
                                                                # Construct the new flattened field name
                                                                target_key = "dms.resellerInfo.additionalFields.#{field_name}"
                                                                event.set(target_key, field_value)
                                                            end
                                                        end
                                                    end
                                                end
                                            end
                                        }
                                    else
                                        keyField="dms.#{key}"
                                        event.set(keyField,value)
                                    end
                                  }
                          '
               }
               mutate
               {
                      remove_field=>["DMS"]
               }
               if ![dms.resellerInfo.additionalFields.circleName] {
                   translate
                   {
                       field => "dms.resellerInfo.additionalFields.circle" # Replace with the actual field name holding the ID (e.g., "territory_id")
                       destination => "dms.resellerInfo.additionalFields.circleName"          # Replace with the desired output field name
                       dictionary_path => "/opt/seamless/conf/logstash/region_map.yaml" # Update the path
                       fallback => "ID_Not_Found"            # Optional: Value if ID isn't in the dictionary
                   }
               }
               if ![dms.resellerInfo.additionalFields.regionName] {
                   translate
                   {
                       field => "dms.resellerInfo.additionalFields.region" # Replace with the actual field name holding the ID (e.g., "territory_id")
                       destination => "dms.resellerInfo.additionalFields.regionName"          # Replace with the desired output field name
                       dictionary_path => "/opt/seamless/conf/logstash/region_map.yaml" # Update the path
                       fallback => "ID_Not_Found"            # Optional: Value if ID isn't in the dictionary
                   }
               }
               if ![dms.resellerInfo.additionalFields.clusterName] {
                   translate
                   {
                       field => "dms.resellerInfo.additionalFields.cluster" # Replace with the actual field name holding the ID (e.g., "territory_id")
                       destination => "dms.resellerInfo.additionalFields.clusterName"          # Replace with the desired output field name
                       dictionary_path => "/opt/seamless/conf/logstash/region_map.yaml" # Update the path
                       fallback => "ID_Not_Found"            # Optional: Value if ID isn't in the dictionary
                   }
               }
               if ![dms.resellerInfo.additionalFields.territoryName] {
                   translate
                   {
                       field => "dms.resellerInfo.additionalFields.territory" # Replace with the actual field name holding the ID (e.g., "territory_id")
                       destination => "dms.resellerInfo.additionalFields.territoryName"          # Replace with the desired output field name
                       dictionary_path => "/opt/seamless/conf/logstash/region_map.yaml" # Update the path
                       fallback => "ID_Not_Found"            # Optional: Value if ID isn't in the dictionary
                   }
               }
               # Fetch parent MSISDN if reseller type is RET or GPCF
               if [dms.resellerInfo.reseller.resellerTypeId] == "RET" or [dms.resellerInfo.reseller.resellerTypeId] == "GPCF"
               {
                    # Only query if parentResellerId exists
                    if [dms.resellerInfo.reseller.parentResellerId]
                    {
                          elasticsearch
                          {
                                hosts => [ "https://{{ .Values.HOST__elasticsearch }}:{{ .Values.PORT__elasticsearch }}" ]
                                user => {{ .Values.HOST__elasticsearch_user }}
                                password => {{ .Values.HOST__elasticsearch_pass }}
                                ssl => true
                                ca_file => "/opt/seamless/conf/logstash/cert/http_ca.crt"
                                index => "reseller_data_lake" # Verify this index pattern is correct
                                query_template => '/opt/seamless/conf/logstash/parentResellerQuery.json'
                                fields => {
                                "dms.resellerInfo.reseller.resellerMSISDN" => "[@metadata][parent_msisdn_array]"
				 }
                                enable_sort => false # Sorting is not needed for a size:1 query
                          }
                          ruby
                          {
                                code => '
                                	event.set("dms.resellerInfo.reseller.parentResellerMSISDN", event.get("[@metadata][parent_msisdn_array]"))
					# Clean up the temporary metadata field
                                	event.remove("[@metadata][parent_msisdn_array]")
                                '
                          }
                    }
                          ruby
                          {
                                code => '
                                        event_name = event.get("eventName")
                                        puts "event is #{event_name}"
                                    '
                          }
                    if [eventName] == "updateReseller"
                    {
                          ruby
                          {
                                code => '
                                        puts "here for updateReseller"
                                '
                          }
                        elasticsearch
                        {
                            hosts => [ "https://{{ .Values.HOST__elasticsearch }}:{{ .Values.PORT__elasticsearch }}" ]
                            user => {{ .Values.HOST__elasticsearch_user }}
                            password => {{ .Values.HOST__elasticsearch_pass }}
                            ssl => true
                            ca_file => "/opt/seamless/conf/logstash/cert/http_ca.crt"
                            index => "reseller_data_lake"
                            query_template => "/opt/seamless/conf/logstash/fetchRTRDetails.json"
                            fields =>
                            {
                                "dms.resellerInfo.dynamicData.pos" => "[@metadata][pos]"
                            }
                            enable_sort => false
                        }
                        ruby
                        {
			     code => '
                                require "set"

                                # Helper function to extract active partner types from a pos_array
                                # Ensure pos_array is not nil and is an array before processing
                                def get_active_partner_types(pos_array)
                                  # Default to an empty array if pos_array is nil or not an array to prevent errors
                                  safe_pos_array = pos_array.is_a?(Array) ? pos_array : []

                                  safe_pos_array.select { |p| p.is_a?(Hash) && p["partnerStatus"] == "active" && p.key?("partnerType") }
                                                .map { |p| p["partnerType"] }
                                                .compact # Ensures no nil types if partnerType key was missing despite check
                                                .to_set
                                end

                                incoming_pos = event.get("dms.resellerInfo.dynamicData.pos")
                                existing_pos = event.get("[@metadata][pos]") # This comes from the ES lookup
                                update_timestamp = event.get("timestamp")

                                # Get active types using the helper
                                active_incoming_types = get_active_partner_types(incoming_pos)
                                active_existing_types = get_active_partner_types(existing_pos)

                                # Determine deboarded and onboarded types based on active status
                                deboarded_types = active_existing_types - active_incoming_types
                                onboarded_types = active_incoming_types - active_existing_types

                                if deboarded_types.any?
                                    deboarded_types.each do |type|
                                        # Create field name like ERS_DEBOARD_DATE, MFS_DEBOARDED_DATE etc.
                                        # Ensure type is not nil or empty before creating field name
                                        if type && !type.empty?
                                            field_name = "#{type.upcase}_DEBOARD_DATE"
                                            # Set the field on the *incoming* event
                                            event.set(field_name, update_timestamp)
                                        end
                                    end
                                end

                                if onboarded_types.any?
                                    onboarded_types.each do |type|
                                        # Ensure type is not nil or empty
                                        if type && !type.empty?
                                            field_name = "#{type.upcase}_ONBOARD_DATE"
                                            event.set(field_name, update_timestamp)
                                        end
                                    end
                                end

                                # --- Cleanup ---
                                # Remove the temporary field fetched from Elasticsearch
                                event.remove("[@metadata][pos]")
			               '
                        }
                    }
                    else if [eventName] == "addReseller"
                    {
                          ruby
                          {
                                code => '
                                        puts "here for addReseller"
                                '
                          }
                        ruby
                        {
                            code => '
                                incoming_pos = event.get("dms.resellerInfo.dynamicData.pos")
                                update_timestamp = event.get("timestamp")

                                onboarded_types = Set.new
                                deboarded_types = Set.new

                                if incoming_pos.is_a?(Array)
                                    incoming_pos.each do |p|
                                        if p.is_a?(Hash)
                                            type = p["partnerType"]
                                            status = p["partnerStatus"] # Get status

                                            # Ensure type is a non-empty string and status is present and a string
                                            if type.is_a?(String) && !type.empty? && status.is_a?(String) && !status.empty?
                                                status_downcased = status.downcase
                                                if status_downcased == "active"
                                                    onboarded_types.add(type)
                                                elsif status_downcased == "inactive"
                                                    deboarded_types.add(type)
                                                end
                                            end
                                        end
                                    end
                                end

                                if onboarded_types.any?
                                    onboarded_types.each do |type|
                                        # type is already validated as a non-empty string before adding to the Set
                                        field_name = "#{type.upcase}_ONBOARD_DATE"
                                        event.set(field_name, update_timestamp)
                                    end
                                end

                                if deboarded_types.any?
                                    deboarded_types.each do |type|
                                        # type is already validated as a non-empty string before adding to the Set
                                        field_name = "#{type.upcase}_DEBOARD_DATE"
                                        event.set(field_name, update_timestamp)
                                    end
                                end
                            '
                        }
                    }
                }
           }
           else if [eventName] in ["ADD_GROUP_ADMINS_UPDATED", "REMOVE_GROUP_ADMINS_UPDATED", "REMOVE_GROUP_ADMINS_BY_USER_ID_UPDATED"] and [resultcode] == "0"
           {
                    ruby
                    {
                                code => '
                                    admins = event.get("admins")
			            user_id = admins[0]["userId"]
                                    event.set("dms.resellerInfo.reseller.resellerId", user_id)
                                '
                    }

                    prune
                    {
                            whitelist_names => ["^eventName$","^dms.resellerInfo.reseller.resellerId$", "^routeCode$", "^routeName$","^routeFrequency$"]
                    }
                    # 1. Check if the event is removing an admin
                    if [eventName] in ["REMOVE_GROUP_ADMINS_UPDATED", "REMOVE_GROUP_ADMINS_BY_USER_ID_UPDATED"]
                    {
                        ruby
                        {
                            code => '
                                event.set("[@metadata][se_reseller_id]", "N/A")
                                event.set("[@metadata][se_status]", "N/A")
                                event.set("[@metadata][se_name]", "N/A")
                                event.set("[@metadata][se_msisdn]", "N/A")
                                se_reseller_id=event.get("dms.resellerInfo.reseller.resellerId")
  				puts "fetching existing route code for se = #{se_reseller_id}"
                            '
                        }
                        elasticsearch
                        {
                              hosts => [ "https://{{ .Values.HOST__elasticsearch }}:{{ .Values.PORT__elasticsearch }}" ]
                              user => {{ .Values.HOST__elasticsearch_user }}
                              password => {{ .Values.HOST__elasticsearch_pass }}
                              ssl => true
                              ca_file => "/opt/seamless/conf/logstash/cert/http_ca.crt"
                              index => "reseller_data_lake"
                              query_template => "/opt/seamless/conf/logstash/fetchSEDetails.json"
                              fields =>
                              {
                                "routeCode" => "[@metadata][route_code]"
                              }
                              enable_sort => false
                        }
                        ruby
                        {
                            code => '
                                current_route_code = event.get("[@metadata][route_code]")
                                puts "SE will be removed from routeCode #{current_route_code}"
                                event.set("current_route_code", current_route_code)
                            '
                        }
                    }
                    else
                    {
                        ruby
                        {
                            code => '
                                croute_code=event.get("routeCode")
                                se_reseller_id=event.get("dms.resellerInfo.reseller.resellerId")
				puts "SE #{se_reseller_id} will be added to routeCode #{croute_code}"
                            '
                        }
                        elasticsearch
                        {
                              hosts => [ "https://{{ .Values.HOST__elasticsearch }}:{{ .Values.PORT__elasticsearch }}" ]
                              user => {{ .Values.HOST__elasticsearch_user }}
                              password => {{ .Values.HOST__elasticsearch_pass }}
                              ssl => true
                              ca_file => "/opt/seamless/conf/logstash/cert/http_ca.crt"
                              index => "reseller_data_lake"
                              query_template => "/opt/seamless/conf/logstash/fetchSEDetails.json"
                              fields =>
                              {
                                "dms.resellerInfo.reseller.resellerId" => "[@metadata][se_reseller_id]"
                                "dms.resellerInfo.reseller.status" => "[@metadata][se_status]"
                                "dms.resellerInfo.reseller.resellerName" => "[@metadata][se_name]"
                                "dms.resellerInfo.reseller.resellerMSISDN" => "[@metadata][se_msisdn]"
                              }
                              enable_sort => false
                        }
                        ruby
                        {
                            code => '
                                  event.set("current_route_code", event.get("routeCode"))
                                  '
                        }
                    }
                    # 2. Fetch all RET resellerIds for the same routeCode
                    elasticsearch
                    {
                        hosts => [ "https://{{ .Values.HOST__elasticsearch }}:{{ .Values.PORT__elasticsearch }}" ]
                        user => {{ .Values.HOST__elasticsearch_user }}
                        password => {{ .Values.HOST__elasticsearch_pass }}
                        ssl => true
                        ca_file => "/opt/seamless/conf/logstash/cert/http_ca.crt"
                        index => "reseller_data_lake"
                        query_template => "/opt/seamless/conf/logstash/retailerQuery.json"
                        fields =>
                        {
                          "dms.resellerInfo.reseller.resellerId" => "ret_reseller_ids"
                        }
                        enable_sort => false
                    }
                    ruby
                    {
                        code => '
                                retailerIds = event.get("ret_reseller_ids")
                                puts "retailerIds #{retailerIds}"
                                # remove the current_route_code from the retailerIds array
                                event.remove("current_route_code")
                        '
	            }
                    if ([ret_reseller_ids] and [ret_reseller_ids][0])
		    {
                    	# 3. Split the event into multiple events, one for each RET
                    	split
                    	{
                      		field => "ret_reseller_ids"
                    	}
                    	mutate
			{
                        	rename => {"ret_reseller_ids" => "ret_reseller_id"}
		        }
			ruby
			{
                        	code => '
                                	retailerId = event.get("ret_reseller_id")
                                	puts "retailerId = #{retailerId}"
                        	'
                    	}
                    	# 4. Set SE details as top-level fields for output
                    	ruby
                    	{
                      		code => '
                        		event.set("se_reseller_id", event.get("[@metadata][se_reseller_id]"))
                        		event.set("se_status", event.get("[@metadata][se_status]"))
                        		event.set("se_name", event.get("[@metadata][se_name]"))
                        		event.set("se_msisdn", event.get("[@metadata][se_msisdn]"))
                        		# Clean up the temporary metadata field used for the lookup result
                        		event.remove("[@metadata][se_reseller_id]")
                        		event.remove("[@metadata][se_status]")
                        		event.remove("[@metadata][se_name]")
                        		event.remove("[@metadata][se_msisdn]")
                      		'
                    	}
                    }
           }
	   else if [eventName] in ["ADD_GROUP_MEMBERS_UPDATED", "REMOVE_GROUP_MEMBERS_UPDATED"] and [resultcode] == "0"
           {
                  if [eventName] == "ADD_GROUP_MEMBERS_UPDATED"
                  {
                        # Query Elasticsearch to find the SE details based on routeCode
                        elasticsearch
                        {
                              hosts => [ "https://{{ .Values.HOST__elasticsearch }}:{{ .Values.PORT__elasticsearch }}" ]
                              user => {{ .Values.HOST__elasticsearch_user }}
                              password => {{ .Values.HOST__elasticsearch_pass }}
                              ssl => true
                              ca_file => "/opt/seamless/conf/logstash/cert/http_ca.crt"
                              index => "reseller_data_lake" # Verify this index pattern is correct for SE info
                              # Query for a document matching the routeCode from the event and resellerTypeId 'SE'
                              query_template => "/opt/seamless/conf/logstash/seRouteCodeQuery.json"
			      fields =>
                              {
                                "dms.resellerInfo.reseller.resellerId" => "[@metadata][se_info][se_reseller_id]"
                                "dms.resellerInfo.reseller.status" => "[@metadata][se_info][se_status]"
                                "dms.resellerInfo.reseller.resellerName" => "[@metadata][se_info][se_name]"
                                "dms.resellerInfo.reseller.resellerMSISDN" => "[@metadata][se_info][se_msisdn]"
                              }
                              enable_sort => false # Sorting is not needed for a size:1 query
                              user => {{ .Values.HOST__elasticsearch_user }}
                              password => {{ .Values.HOST__elasticsearch_pass }}
                        }

                        # Add the fetched fields to the event under dms.resellerInfo
                        # Use ruby to safely access the first element of the array returned by the ES filter
                        # and provide 'N/A' as a default if the lookup failed or the field was missing.
                        ruby
                        {
                            code => '
                              event.set("se_reseller_id", event.get("[@metadata][se_info][se_reseller_id]"))
                              event.set("se_status", event.get("[@metadata][se_info][se_status]"))
                              event.set("se_name", event.get("[@metadata][se_info][se_name]"))
                              event.set("se_msisdn", event.get("[@metadata][se_info][se_msisdn]"))
                              # Clean up the temporary metadata field used for the lookup result
                              event.remove("[@metadata][se_info][se_reseller_id]")
                              event.remove("[@metadata][se_info][se_status]")
                              event.remove("[@metadata][se_info][se_name]")
                              event.remove("[@metadata][se_info][se_msisdn]")
                            '
                        }
                  }
                  else if [eventName] == "REMOVE_GROUP_MEMBERS_UPDATED"
                  {
                        # For removal events, directly set the SE fields to 'N/A'
                        mutate
                        {
                            add_field =>
                            {
                                "se_reseller_id" => "N/A"
                                "se_status" => "N/A"
                                "se_name" => "N/A"
                                "se_msisdn" => "N/A"
                            }
                        }
                  }
                  split
                  {
                          field => "members"
                  }
                  mutate
                  {
                          rename => { "[members]" => "member" }
                  }
                  ruby
                  {
                              code => '
                                  event.set("dms.resellerInfo.reseller.resellerId", event.get("[member][userId]"))
                              '
                  }
                  prune
                  {
                          whitelist_names => ["^dms.resellerInfo.reseller.resellerId$", "^routeCode$", "^routeName$", "^routeFrequency$", "^se_reseller_id$", "^se_status$", "^se_name$", "^se_msisdn$", "^eventName$"]
                  }
           }
           else if [eventName] == "resellerChangeState"
           {
                # Process only if the reseller status within the first DMS element is Deactivated
                if [DMS][0][resellerStatus] == "Deactivated"
                {
                    # Extract and rename relevant fields
                    mutate
                    {
                        add_field => {
                            "dms.resellerInfo.reseller.resellerId" => "%{[DMS][0][resellerId]}"
                            "dms.resellerInfo.reseller.status" => "%{[DMS][0][resellerStatus]}"
                        }
                    }

                    # Extract and format the timestamp to DEACTIVATION_DATE (mm/DD/yyyy)
                    ruby
                    {
                        code => '
                            require "time"
                            begin
                                # Safely access the timestamp field
                                ts = event.get("timestamp")
                                if ts
                                    # Parse the timestamp string (format: yyyy-MM-dd HH:mm:ss)
                                    parsed_time = Time.strptime(ts, "%Y-%m-%d %H:%M:%S")
                                    # Format the date as mm/DD/yyyy
                                    event.set("DEACTIVATION_DATE", parsed_time.strftime("%m/%d/%Y"))
                                    event.set("MFS_DEBOARD_DATE", ts)
                                    event.set("ERS_DEBOARD_DATE", ts)
                                    event.set("TELCO_DEBOARD_DATE", ts)
                                    event.set("SC_DEBOARD_DATE", ts)
                                else
                                    # Handle case where timestamp field is missing
                                    event.set("DEACTIVATION_DATE", "N/A")
                                end
                            rescue ArgumentError => e
                                # Handle potential errors if the timestamp format is unexpected
                                event.set("DEACTIVATION_DATE", "N/A")
                                event.tag("_dateparsefailure_resellerChangeState")
                            rescue => e
                                # Handle other potential errors during ruby execution
                                event.set("DEACTIVATION_DATE", "N/A")
                                event.tag("_rubyerror_resellerChangeState")
                            end
                        '
                    }

                    # Keep only the required fields for this event type
                    prune
                    {
                        whitelist_names => [
                            "^dms.resellerInfo.reseller.resellerId$",
                            "^dms.resellerInfo.reseller.status$",
                            "^DEACTIVATION_DATE$",
                            "^eventName$"
                        ]
                        # Use regex for nested fields, escaping dots
                    }
                }
                else
                {
                    # If eventName is resellerChangeState but status is not Deactivated, drop the event
                    drop {}
                }
           }
           else
           {
                  drop {}
           }
        }
        else
        {
               ruby
               {
                    code => "
                        puts 'Transaction skipped due to invalid JSON format'
                        require 'date'
                        week_n = event.get('@timestamp').time.strftime '%V'
                        month_n = event.get('@timestamp').time.strftime '%m'
                        year_n = event.get('@timestamp').time.strftime '%Y'
                        if(week_n == '01' && month_n == '12')
                        year_n = (year_n.to_i + 1)
                        week_num = year_n.to_s + 'w' + week_n.to_s
                        else if (month_n == '01' && week_n.to_i > 50)
                        year_n = (year_n.to_i - 1)
                        week_num = year_n.to_s + 'w' + week_n.to_s
                        else
                        week_num = year_n + 'w' + week_n
                        end
                        end
                        event.set('[@metadata][week_num]', week_num)
                    "
                }
        }
}
output
{
        if "_jsonparsefailure" in [tags]
        {
            elasticsearch
            {
                action => "index"
                hosts => [ "https://{{ .Values.HOST__elasticsearch }}:{{ .Values.PORT__elasticsearch }}" ]
                user => {{ .Values.HOST__elasticsearch_user }}
                password => {{ .Values.HOST__elasticsearch_pass }}
                ssl => true
                cacert => "/opt/seamless/conf/logstash/cert/http_ca.crt"
                index => "reseller_txn_parsing_failure_%{[@metadata][week_num]}"
            }
        }
        else
        {
            if [eventName] in ["ADD_GROUP_ADMINS_UPDATED", "REMOVE_GROUP_ADMINS_UPDATED", "ADD_GROUP_MEMBERS_UPDATED", "REMOVE_GROUP_MEMBERS_UPDATED", "REMOVE_GROUP_ADMINS_BY_USER_ID_UPDATED"]
            {
                if [ret_reseller_id]
                {
                    elasticsearch
                    {
                        action => "update"
                        hosts => [ "https://{{ .Values.HOST__elasticsearch }}:{{ .Values.PORT__elasticsearch }}" ]
                        user => {{ .Values.HOST__elasticsearch_user }}
                        password => {{ .Values.HOST__elasticsearch_pass }}
                        ssl => true
                        cacert => "/opt/seamless/conf/logstash/cert/http_ca.crt"
                        index  => "reseller_data_lake"
                        document_id => "%{ret_reseller_id}"
                        doc_as_upsert => true
                        script => '
                        ctx._source.se_reseller_id = params.event.get("se_reseller_id");
                        ctx._source.se_name = params.event.get("se_name");
                        ctx._source.se_msisdn = params.event.get("se_msisdn");
                        ctx._source.se_status = params.event.get("se_status");
                        '
                        script_type => "inline"
                        script_lang => "painless"
                    }
                }
                elasticsearch
                {
                        action => "update"
                        hosts => [ "https://{{ .Values.HOST__elasticsearch }}:{{ .Values.PORT__elasticsearch }}" ]
                        user => {{ .Values.HOST__elasticsearch_user }}
                        password => {{ .Values.HOST__elasticsearch_pass }}
                        ssl => true
                        cacert => "/opt/seamless/conf/logstash/cert/http_ca.crt"
                        index  => "reseller_data_lake"
                        document_id => "%{dms.resellerInfo.reseller.resellerId}"
                        doc_as_upsert => true
                }
            }
            else if ![dms.resellerInfo.reseller.resellerId]
            {
                   elasticsearch
                   {
                        action => "index"
                        hosts => [ "https://{{ .Values.HOST__elasticsearch }}:{{ .Values.PORT__elasticsearch }}" ]
                        user => {{ .Values.HOST__elasticsearch_user }}
                        password => {{ .Values.HOST__elasticsearch_pass }}
                        ssl => true
                        cacert => "/opt/seamless/conf/logstash/cert/http_ca.crt"
                        index => "reseller_txn_parsing_failure_%{[@metadata][week_num]}"
                   }
             }
             else
             {
                   elasticsearch
                   {
                        action => "update"
                        hosts => [ "https://{{ .Values.HOST__elasticsearch }}:{{ .Values.PORT__elasticsearch }}" ]
                        user => {{ .Values.HOST__elasticsearch_user }}
                        password => {{ .Values.HOST__elasticsearch_pass }}
                        ssl => true
                        cacert => "/opt/seamless/conf/logstash/cert/http_ca.crt"
                        index => "reseller_data_lake"
                        document_id => "%{dms.resellerInfo.reseller.resellerId}"
                        doc_as_upsert => true
                   }
             }
        }

        stdout { codec => rubydebug}
}
